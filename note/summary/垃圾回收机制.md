##### 为什么要释放不再用到的内存

* 主要是会使内存占用持续升高，一方面会影响程序运行速度，另一方面会导致整个程序崩溃



##### `javaScirpt` 中的垃圾回收机制

* `js`中的提供了自动内存管理机制，成为 `垃圾回收机制` 简称 `GC机制`

##### 全停顿

* 垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后在执行应用逻辑。此行为称为 ` 全停顿`，主要目的是为了解决应用逻辑与垃圾回收器看到的情况不一致的问题

##### `js`中的垃圾回收

​	被判定为垃圾的情况如下：

- 对象不再被引用
- 对象不能从根上面访问到

#### `GC` 算法

常见的`GC` 算法如下：

- 引用计数

- 标记清除

- 标记整理

- 增量标记

- 分代回收（新生代和老生代）

  

##### 1. 引用计数

早期的浏览器最常用的垃圾回收方法叫 `引用计数` ， 语言引擎有一张 ‘引用表’， 保存内存里所有的资源引用次数，如果一个值的引用次数是0，表示不再用到。因此将这块内存释放掉。

* 缺点： 最大的问题就是循环引用。循环引用就是不同的对象通过各自的属性互相引用，这样他们的引用计数都不为0，这样就不会被回收，造成内存的浪费

  循环引用示例代码：

  ```js
  function objGroup(obj1, obj2) {
      obj1.next = obj2
      obj2.prev = obj1
  
      return {
          o1: obj1,
          o2: obj2,
      }
  }
  
  let obj = objGroup({name: 'obj1'}, {name: 'obj2'})
  console.log(obj)
  ```

  还有一个较大的缺点就是需要拿出一片空白空间去维护每一个变量的引用计数，对于大程序来说空间开销还是比较大。

* 优点： 1.引用计数为0时，发现垃圾立即回收。 2. 最大限度减少程序暂停

##### 2. 标记清除

核心思想： 分标记和清除两个阶段

1. 遍历所有对象找标记活动对象
2. 遍历所有对象清除没有标记对象
3. 回收相应的空间

优点：

* 对比引用计数算法，能够回收循环引用的对象

缺点： 

* 空间碎片化，导致被回收的空间不能被分配



##### 3. 标记整理

为了解决内存碎片化问题。提高对内存的利用率，引入此算法。可以看做是标记清除的 `增强` ，标记阶段和标记清除算法一致。清除阶段会先执行整理，移动对象位置，将存活的对象放到一边，然后再清理端边界外的内存。

缺点： 移动对象的位置，不会被立即回收，回收率比较慢

##### 4. 增量标记

为了减少全停顿的时间，`V8` 对标记进行了优化。将一次停顿进行的标记过程，分成很多小步。每执行完一小步就让应用逻辑执行一会，这样交替多次后完成标记

--------标记---------->-----------逻辑----------->--整理--> 清除

---标记-->---逻辑--->----标记---->---逻辑--->--整理--> 清除

* 主要是为了解决长时间的`GC` 会导致应用暂停和无响应，2011年开始`V8` 将暂停标记改为增量标记。修改后最大暂停时间减少到原来的1/6



#### `V8 ` 引擎垃圾回收策略

- 采用分代回收方法
- 内存分为新生代和老生代

对于不同的对象使用不同的算法

1. 新生代：对象存活时间较短，新生对象或只经过一次垃圾回收的对象
2. 老生代： 存活时间较长，经历过一次或多次垃圾回收的对象

`V8` 堆的空间分为新生代空间和老生代空间，且对不同的空间做了限制。限制的原因： 经过不断测试，如果内存超过限制的大小，`GC` 回收的时间会达到用户的感知，会造成感知上的卡顿

##### 回收新生代对象

主要采用 `复制算法` 加 `标记整理算法` 。复制算法将内存空间分为两个等大空间，使用空间为From,空闲空间为 To. 

算法的过程是： 检查From空间内的存活对象，若对象存活，检查对象是否符合晋升条件，若符合晋升条件则晋升到老生代，否则从From空间复制到To空间，若对象不存活，释放不存活的对象空间，完成复制后将From空间与To空间进行角色调换(就是To变成From,From变成To)。

* 对象晋升机制： 1. 一轮`GC` 还存活的新生代需要晋升。2. 从From空间复制到To时，To空间使用超过25%，则对像直接晋升到老生代中。主要原因是： To和From角色转换后，继续进行对象内存的分配，若占比过大，将影响后续内存的分配。



##### 回收老生代对象

回收老生代对象主要使用` 标记清除` 、`标记整理` 、` 增量标记` 算法。主要使用标记清除，只有在内存分配不足时，采用标记整理。

1. 首先使用标记清除完成垃圾空间的回收
2. 采用标记整理进行空间优化
3. 采用增量标记进行效率优化



新生代和老生代回收对比

新生代由于占用空间比较少，采用空间换时间机制

老生代区域空间比较大，不适合大量的复制算法和标记整理，所以使用标记清除让全停顿的时间减少。



##### 性能优化

1. 避免使用全局变量

   - 全局变量挂载在windows下
   - 全局变量至少有一个引用计数
   - 全局变量存活久，持续占用内存
   - 在明确数据作用域下，尽量使用局部变量

2. 减少判断层级

3. 减少数据读取次数，对于频繁使用的数据，我们要对数据进行缓存。如：

   ```
   var oBox = document.getElementById('skip')
   ```

4. 减少循环体中的活动

   ```js
   var test = () => {
       var i
       var arr = ['Hello World!', 25, '岂曰无衣，与子同袍']
       for(i = 0; i < arr.length; i++) {
           console.log(arr[i])
       }
   }
   
   // 优化后，将arr.length单独提出，防止每次循环都获取一次
   var test = () => {
       var i
       var arr = ['Hello World!', 25, '岂曰无衣，与子同袍']
       var len = arr.length
       for(i = 0; i < len; i++) {
           console.log(arr[i])
       }
   }
   
   ```

5. 避开闭包陷阱



